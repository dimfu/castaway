package views

templ Index() {
@Layout() {
<div class="flex mx-auto items-center justify-center">
	<div class="flex items-center justify-center p-2 md:pd-0">
		<div class="md:w-[29em] md:max-w-[29em] outline-1 outline-solid shadow-[6px_6px_rgba(0,0,0,0.3)]">
			<div
				class="bg-[var(--antique-white)] bg-[url('/public/bg-noise.png'),_linear-gradient(rgba(255,255,255,0.1),_rgba(255,255,255,0.1))] bg-[auto,_auto] bg-repeat p-4">
				<h1 class="font-bold text-4xl">Castaway</h1>
				<small class="text-base">
					Send files easily from the browser to other peer with no file size
					limitation.
				</small>
				<div class="w-full">
					<img src="https://cdn.prod.website-files.com/63d10707b249a7daee263cf7/63d10707b249a72f70263d91_line-system.svg"
						alt="" class="block opacity-25 my-2 w-full" />
				</div>
				<h2 class="font-semibold text-2xl mb-1.5">Share Files</h2>
				<div class="mb-1.5" id="selected_container" style="display: none;">
					<h3 class="text-xl">Files Selected</h3>
					<ul class="list-disc list-inside" id="selected_files"></ul>
					<small>Total Size: <span id="total_size"></span></small>
				</div>
				<form hx-target="#statusContainer" hx-swap="none" class="flex flex-col w-full"
					id="uploadForm" hx-post="/init-upload" hx-on::after-request="initUpload(event)">
					<input class="outline-1 w-full p-1 file:outline-1 file:p-1 file:mr-2"
						id="fileInput" type="file" multiple onchange="handleFileChange()" />
					<input type="hidden" name="file_name" />
					<input type="hidden" name="file_size" />
					<input type="hidden" name="file_type" />
					<button style="display: none;" id="uploadBtn" disabled type="submit" class="
						mx-auto
						mt-4
						min-h-[2.25em] 
						bg-[var(--antique-white)] 
						text-[var(--black)] 
						text-center 
						border border-black 
						text-base font-bold leading-[1.5] 
						transition-none 
						shadow-[3px_3px_#000] 
						w-40 max-w-full 
						hover:translate-x-[4px] hover:translate-y-[4px] hover:shadow-none">
						Share Now
					</button>
				</form>
				<div style="display: none" id="proccessingContainer"
					class="mt-1.5 p-2 bg-[rgba(74,229,181,0.3)] outline-[rgb(74,229,181)]-1">
					<small
						class="font-semibold after:content-[''] after:inline-block after:animate-ellipsis">Processing</small>
					<p>
						Since there is multiple files that are being selected, the browser needs
						to
						archive the files into a ZIP archive. Please wait
					</p>
				</div>
				<div id="statusContainer"></div>
			</div>
		</div>
	</div>
</div>
}
<script type="text/javascript" src="/public/js/zip-full.min.js"></script>
<script>
	let socket
	let clearedOnce

	// to track download progress
	let uploadedChunkCount = 0
	let chunksLength = 0

	document.addEventListener('DOMContentLoaded', function () {
		if (clearedOnce) return
		clearedOnce = true
		clearFormInputs()
	})

	function clearFileInput() {
		const fileInput = document.getElementById('fileInput')
		if (fileInput) {
			fileInput.value = ''
			fileInput.dispatchEvent(new Event('change', {bubbles: true}))
		}
	}

	function clearFormInputs() {
		const form = document.getElementById('uploadForm')
		if (form) {
			form.reset()
		}
	}

	function handleUploadSocket(socket, file, chunks) {
		socket.onopen = () => {
			console.info("Waiting for receiver")
		}
		socket.addEventListener("message", (event) => {
			const data = JSON.parse(event.data)
			switch (data.type) {
				case "start_download":
					console.log("Client triggered download, start uploading...")
					let offset = 0
					chunksLength = chunks.length
					console.log("Chunks length", chunksLength)
					for (const chunk_size of chunks) {
						socket.send(file.slice(offset, offset + chunk_size))
						offset += chunk_size
					}
					clearFormInputs()
					window.currentUploadFile = null
					break
				case "upload_chunk_success":
					uploadedChunkCount++
					const percent = (uploadedChunkCount / chunksLength) * 100
					document.getElementById("uploadProgress").value = percent
					document.getElementById("uploadPercentage").textContent = `${percent.toFixed(1)}`
				default:
					console.log(data.type)
			}
		})
	}

	async function handleFileChange() {
		const fileInput = document.getElementById("fileInput")

		// file that will be sent to the server or client
		let file
		const inputFiles = fileInput.files
		if (inputFiles.length > 1) {
			document.getElementById("proccessingContainer").style.display = "block"
			let selectedContainer = document.getElementById("selected_container")
			selectedContainer.style.display = "block"
			let fileUlElement = document.getElementById("selected_files")
			const zipWriter = new zip.ZipWriter(new zip.BlobWriter("application/zip"))
			await Promise.all([...inputFiles].map(f => {
				let fileLiElement = document.createElement("li")
				fileLiElement.textContent = f.name
				fileUlElement.appendChild(fileLiElement)
				return zipWriter.add(f.name, new zip.BlobReader(f))
			}))
			file = await zipWriter.close()
			file = new File([file], "files.zip", {type: "application/zip"})
			let totalSizeEl = document.getElementById("total_size")
			totalSizeEl.textContent = (file.size / (1024 * 1024)).toFixed(2) + " MB"
		} else if (inputFiles.length === 1) {
			file = inputFiles[0]
		}

		if (file) {
			document.getElementById("proccessingContainer").style.display = "none"
			document.getElementById("uploadBtn").style.display = "block"
			console.log("File selected:", file.name, file.size, file.type)
			window.currentUploadFile = file
			const form = document.getElementById('uploadForm')
			form.querySelector('input[name="file_name"]').value = file.name
			form.querySelector('input[name="file_size"]').value = file.size
			form.querySelector('input[name="file_type"]').value = file.type

			const uploadBtn = document.getElementById("uploadBtn")
			uploadBtn.disabled = false
		} else {
			window.currentUploadFile = null
			const form = document.getElementById('uploadForm')
			form.querySelector('input[name="file_name"]').value = ''
			form.querySelector('input[name="file_size"]').value = ''
			form.querySelector('input[name="file_type"]').value = ''
		}
	}

	function initUpload(event) {
		const {xhr} = event.detail
		const file = window.currentUploadFile

		if (!file) {
			console.error("No file selected")
			return
		}

		console.log("Initializing upload for:", file.name)

		try {
			const data = JSON.parse(xhr.responseText)
			document.getElementById("uploadForm").innerHTML = `
				<label>Share this URL with the receiver:</label>
				<div class="flex items-center gap-1">
					<input id="download_url" class="flex-1 p-1 outline" type="text" value="${data.url}"/>
					<button type="button" id="copyBtn" class="
						mx-auto
						min-h-[2.25em] 
						bg-antique-white 
						text-[var(--black)] 
						text-center 
						border border-black 
						text-base font-bold leading-[1.5] 
						w-24 
					">
						Copy
					</button>
				</div>
				<div class="flex flex-col">
					<label>Upload Progress:</label>
					<progress class="bg-antique-white" id="uploadProgress" value="0" max="100"></progress>
					<small><span id="uploadPercentage">0</span>%</small>
				</div>
				<div class="outline-[#f36a29] bg-[#f36a294d] p-2">
					Please keep this tab open and don't switch to another tab or window until the upload is complete to avoid connection issues and ensure faster upload speeds.
				</div>
			`

			document.getElementById("copyBtn").addEventListener("click", function () {
				copyToClipboard(document.getElementById("download_url"))
			})

			if (data.url && file) {
				const key = data.url.split("/").pop()
				const protocol = window.location.protocol === "https:" ? "wss" : "ws"
				socket = new WebSocket(`${protocol}://${window.location.host}/ws/${key}`)
				handleUploadSocket(socket, file, data.chunks, key)
			} else {
				throw new Error("Missing download url or file")
			}
		} catch (err) {
			console.error(err)
		}
	}

	// https://stackoverflow.com/a/51158332/28430099
	function copyToClipboard(elem) {
		// create hidden text element, if it doesn't already exist
		var targetId = "_hiddenCopyText_"
		var isInput = elem.tagName === "INPUT" || elem.tagName === "TEXTAREA"
		var origSelectionStart, origSelectionEnd
		if (isInput) {
			// can just use the original source element for the selection and copy
			target = elem
			origSelectionStart = elem.selectionStart
			origSelectionEnd = elem.selectionEnd
		} else {
			return
		}
		// select the content
		var currentFocus = document.activeElement
		target.focus()
		target.setSelectionRange(0, target.value.length)

		// copy the selection
		var succeed;
		try {
			succeed = document.execCommand("copy")
			document.getElementById("copyBtn").textContent = "Copied!"
		} catch (e) {
			succeed = false
		}
		// restore original focus
		if (currentFocus && typeof currentFocus.focus === "function") {
			currentFocus.focus()
		}

		if (isInput) {
			// restore prior selection
			elem.setSelectionRange(origSelectionStart, origSelectionEnd)
		} else {
			// clear temporary content
			target.textContent = ""
		}
		return succeed
	}

</script>
}
